// Code generated by sqlc. DO NOT EDIT.
// source: usuario.sql

package db

import (
	"context"
	"time"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "Usuarios" (
    nome,
    cpf,
    telefone,
    email,
    endereco,
    data_nascimento,
    senha
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING usuario_id, nome, cpf, telefone, email, endereco, data_nascimento, senha
`

type CreateUserParams struct {
	Nome           string    `json:"nome"`
	Cpf            string    `json:"cpf"`
	Telefone       string    `json:"telefone"`
	Email          string    `json:"email"`
	Endereco       string    `json:"endereco"`
	DataNascimento time.Time `json:"data_nascimento"`
	Senha          int16     `json:"senha"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Usuario, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Nome,
		arg.Cpf,
		arg.Telefone,
		arg.Email,
		arg.Endereco,
		arg.DataNascimento,
		arg.Senha,
	)
	var i Usuario
	err := row.Scan(
		&i.UsuarioID,
		&i.Nome,
		&i.Cpf,
		&i.Telefone,
		&i.Email,
		&i.Endereco,
		&i.DataNascimento,
		&i.Senha,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT usuario_id, nome, cpf, telefone, email, endereco, data_nascimento, senha FROM "Usuarios"
WHERE usuario_id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, usuarioID int32) (Usuario, error) {
	row := q.db.QueryRowContext(ctx, getUser, usuarioID)
	var i Usuario
	err := row.Scan(
		&i.UsuarioID,
		&i.Nome,
		&i.Cpf,
		&i.Telefone,
		&i.Email,
		&i.Endereco,
		&i.DataNascimento,
		&i.Senha,
	)
	return i, err
}

const getUserbyName = `-- name: GetUserbyName :many
SELECT usuario_id, nome, cpf, telefone, email, endereco, data_nascimento, senha FROM "Usuarios"
WHERE nome = $1
OFFSET $2
`

type GetUserbyNameParams struct {
	Nome   string `json:"nome"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetUserbyName(ctx context.Context, arg GetUserbyNameParams) ([]Usuario, error) {
	rows, err := q.db.QueryContext(ctx, getUserbyName, arg.Nome, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Usuario
	for rows.Next() {
		var i Usuario
		if err := rows.Scan(
			&i.UsuarioID,
			&i.Nome,
			&i.Cpf,
			&i.Telefone,
			&i.Email,
			&i.Endereco,
			&i.DataNascimento,
			&i.Senha,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT usuario_id, nome, cpf, telefone, email, endereco, data_nascimento, senha FROM "Usuarios"
ORDER BY usuario_id
LIMIT $1
OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]Usuario, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Usuario
	for rows.Next() {
		var i Usuario
		if err := rows.Scan(
			&i.UsuarioID,
			&i.Nome,
			&i.Cpf,
			&i.Telefone,
			&i.Email,
			&i.Endereco,
			&i.DataNascimento,
			&i.Senha,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
